\chapter{Conclusion}\label{sec:conclusion}

In the beginning of this thesis, we demonstrated a certain type of error in C++ code.  The specific example was of \lstinline{printf}, a non-reentrant function, being called from inside a signal handler.  This one simple problem was expanded to represent a whole class of issues which were easy to describe but difficult to check using existing methods.  To solve this problem, we created a type system and a tool to enforce that type system. 

Funqual turns program source into a directed call graph and gives the user a syntax with which to encode their own constraints into this call graph.  In this call graph, functions are represented as vertices and function calls are represented as edges.  The constraints describe which functions are allowed to call which other functions, or more abstractly, which vertices in the call graph are allowed to have paths to which other vertices.  Given this description of the problem, determining whether a program follows these type constraints is algorithmically simple.  

Chapter~\ref{sec:rules} formalizes these concepts.  Section~\ref{sec:rules:funptrs} describes rules for how function pointers are represented in this graph.  Section~\ref{sec:rules:special} describes how special cases like inheritance and operator overloading are represented in this graph.  Finally Section~\ref{sec:rules:rules} formally describes the rules of the type system and provides some semi-formal arguments that the type system described here is sound.  

Chapter~\ref{sec:application} takes funqual and applies it to three actual C++ projects to enforce realistic constraints.  The first application was a small program which demonstrates funqual's ability to detect re-entrancy errors in code that contains signal handlers.  This project did not originally contain any issues but funqual was able to detect errors that were manually inserted.  The second application was a small operating system kernel written for a class at Cal Poly which demonstrates funqual's ability to detect calls to functions before their associated subsystems were initialized.  Funqual found actual errors in this project that the author did not know about before analysis.  The third application was a robotics library with soft real-time requirements which demonstrates funqual's ability to detect inappropriate calls to slow functions.  Funqual again found actual errors in this project that the authors did not know about before analysis.  All three of these projects had different domain constraints that funqual was used to enforce --- the fact that funqual can correctly analyze and detect a variety of issues shows the versatility of this tool.  

Finally, Chapter~\ref{sec:future} describes all the future research topics that could be pursued via call graph constraint checking.  Some of this future work revolves around improving the tool funqual itself, some of this future work revolves around expanding the scope of the type system, and some of this future work revolves around measuring the impact that call graph constraints have on the development process.  There are a lot of open questions in this area.  Funqual has been demonstrated to detect realistic bugs in non-trivial projects; several of these bugs were unknown to the project authors before analysis.  This shows that the methods described here have considerable potential, and that incorporating a tool like funqual into the project development cycle might significantly reduce the occurrence of these types of errors.  Measuring this impact should be a focal point of future work.  

Static analysis is a fun and interesting topic for research but it is not a purely academic pursuit.  The goal of funqual, and tools like it, is to help people write high quality software.  No single tool can possibly achieve this on its own, but with new tools and new techniques more and more issues can be detected.  Funqual on its own may not have a huge impact on the development cycle, but at this moment the ideas behind funqual are ready to be incorporated into the existing pantheon of C++ static analysis tools.  


