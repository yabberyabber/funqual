\chapter{Introduction}

Writing bug-free software is challenging if not impossible.  In the past 30 years, millions of dollars have been invested in tools that help developers write code that is robust, readable, and correct \cite{staticanal}.  In general these tools fall into two categories:  Dynamic Analysis tools such as gdb, valgrind, and IDA which analyze programs as they are running; and Static Analysis tools such as lint, cppcheck, and GCC -WAll.  All these tools have different use cases and can be used in conjunction to write code that is error-free.

Languages like C++ and java are well suited for static analysis because type information is explicit in the source code and because every identifier must have one singular unambiguous type.  This enables static analysis tools to do a great deal of checking before even running the program.  

The following snippet of C++ code demonstrates this concept:

\begin{lstlisting}[language=C]
    int i = 2 + false;
\end{lstlisting}

The error here is trivial and easy for a human to spot by simple inspection.  However, as code gets more complex and as codebases get larger, errors like this can be hidden by layers of abstraction.  A tool like GCC or cppcheck is able to spot an error like this nearly instantaneously from the perspective of the programmer and is able to do it for massive codebases.  When using a language like python or ruby, an error like this might not be detected until the code is executed which could take minutes or months.  It is clear to see how being able to detect errors like this statically provides great benefit to the programmer.  A classic study by the University of North Carolina in conjunction with Nortel Networks found that the use of automated static analysis can detect certain types of programming errors at approximately the same accuracy as manual code inspection and that this checking can be performed in a fraction of the time \cite{staticanal}.  

In recent years there has been a big push to expand the realm of what can be statically checked.  A very successful example would be the Rust programming language from Mozilla which was designed to provide "strong guarantees about isolation, concurrency, and memory safety" using an innovate set of type annotations and static analysis techniques \cite{rust-is-dope}. 

Interestingly, before the advent of the Rust project, Mozilla had a fairly lengthy relationship with statically checking for some of these things in C++ code using their Pork tool \cite{mozilla-pork, mozilla-pork-blog}.  Using Pork, Mozilla developed a fairly robust set of tooling aimed at using static analysis to detect certain memory issues and API mis-uses in C++ code used in Mozilla projects.  While these tools were never able to do exhaustive program-wide checking, they were able to check a fair number of commonly-occurring issues.  

Of course, there are things which are extremely difficult to statically check in C and C++.  For years, various projects have tried to build tools which can statically analyze code to check for memory errors, unit errors, and infinite loops.  Unfortunately, many of these projects require specific language extensions in order for there to be enough information in the source code for the tools to work.  This is unfortunate because it prevents the tools from being used on code "in the wild", or code that has not been written with the tool in mind.

This thesis explores static analysis of a program's call-graph.  Specifically, we create a tool called funqual which allows C++ programmers to tag certain functions as belonging to certain types and which can statically check the call-graph and function types against a set of user-defined rules.  This call-graph type system is totally orthogonal to the existing C++ typesystem and so does not interfere with or expand the existing type rules which should be familiar to C++ programmers.  Instead, funqual provides an additional set of restrictions which, when used intelligently by the developer, can help to detect certain kinds of errors statically.

Funqual is written using libclang and does not require any additions to the syntax of C++.  As such, funqual can be run on C++17 code "in the wild" (code not designed to work with funqual);  additionally, code which has been annotated for use with funqual can be compiled directly with gcc or clang without any modification.  

This thesis is laid out as follows: TODO





