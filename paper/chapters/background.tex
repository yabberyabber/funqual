\chapter{Background}

This section aims to provide context for the work done in this paper as well as provide some intuition behind ow the solution here was reached.  The first section here touches on the kind of type system which should be familiar to most programmers.  The second section here demonstrates a different sort of type system which may not seem as familiar to readers.  A general explanation of the call tree is given in this section, though it will be developed in more specific detail later in the paper.  

\section{Type Qualifiers on Variables}\label{sec:bac:varqual}

In most research into type-systems, type qualifiers are a way to refine variable types in order to introduce additional constraints.  These type qualifiers can generally be applied to any base type and can often be combined to form even more specific types.  A classic example that most programmers of C-family languages will know is the $const$ type qualifier.  Any identifier with the $const$ qualifier can be initialized with a value but can never be assigned to again.  This restriction can be statically typed and can often help prevent certain types of errors when used intelligently by the programmer \cite{theory-of-qual}.  Another type qualifier which may be familiar to C programmers is $volatile$ which tells the compiler (and programmer) that this variable may be changed suddenly by other execution environments \cite{theory-of-qual}.

Some compilers also have their own compiler-specific type qualifiers.  In Microsoft Visual C++, function parameters that are modified by the caller and referenced by the callee can be annotated with the $[Runtime::InteropServices::Out]$ qualifier to tell the programmer and the compiler that this is an out parameter.  Having a programming environment rich in these type refining qualifiers can help make the intent of source code easier for the programmer to infer and make it possible for those intents to be statically checked by the compiler.  

In the majority of these systems, defining additional type qualifiers is either relegated to the language designers, the compiler writers, or the super-user.  There is not much tooling or support for the average programmer to create their own type qualifiers and there does not seem to be any sort of emphasis on creating project-specific qualifiers to help maintain program semantics.

\section{Type Qualifiers on the Call Tree}\label{sec:bac:calltree}

The focus of this paper is on assigning and qualifying types of functions and enforcing constraints on where they can and cannot be called.  The central notion behind this sort of type checking is that every program has a call tree and that there are certain patterns in the call tree which must be prevented.  

The call tree of a program is a directed graph where every function is a node and where function calls are edges directed from the caller to the callee.  The type qualifiers in this context are applied to the edges and the things we wish to constrain are connections between edges.  Below is an example of a C program as well as the associated call tree.  The notion of a call tree will be expanded on later in this paper but the general concept is demonstrated here.  

\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}[language=C]
int save_the_pandas() {
	stop_deforestation());
	if (pandas_are_saved()) {
		printf("Stopping deforestation saved the pandas!\n");
		return 1;
	}

	breed_and_release_pandas();
	if (pandas_are_saved()) {
		printf("Breeding pandas in captivation and releasing them has saved the pandas!\n");
		return 1;
	}

	return 0;
}
int main(void) {
	if (save_the_pandas()) {
		printf("The pandas have been saved!\n");
	}
}
\end{lstlisting}
\end{minipage}

\input{figures/panda-call-graph}

As demonstrated by figure \ref{fig:pandacallgraph}, if there is a call from function $X$ to function $Y$ in the source code, there will be an edge pointing from node $X$ to node $Y$ in the associated call graph. 
