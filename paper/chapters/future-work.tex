\chapter{Future Work}\label{sec:future}

This work is only a proof-of-concept for funqual and an exploration of user-defined call graph constraints.  As such, it leaves a lot of work open for further exploration.  This work generally falls into three categories: expanding the abilities of the funqual tool, researching the impact that a tool like funqual could have during the development cycle, and expanding the type system discussed in this thesis.  

Funqual lacks many features.  The most striking issue is the ability to check the types of function pointers which are in typedefs, members of arrays, or members of structs.  While it is not impossible to do this currently, some changes to libClang would make it much simpler.  At the moment, when querying an expression in the clang AST to determine the expression's type, attributes that were in the declaration are not included in the type.  If these attributes were included, that would make querying the funqual type of any arbitrary expression trivial since the funqual type is encoded as an attribute.  

This research lacks any form of usability testing.  Funqual as a tool exists, and it can check programs against arbitrary constraints, but we currently have no idea how useful it is.  How often do developers need to check constraints like these?  How easy is funqual for developers to use?  Does a tool like funqual actually help developers while they are developing software?  How do we teach developers to think about the call graph and about how to restrict it?  Static Analysis tools exist to assist the developer and so in order to apply funqual to the real world, all these questions must be answered.

The type system described in this paper supports three types of constraints: $require\_direct\_call$, $restrict\_direct\_call$, and $restrict\_indirect\_call$.  There are without a doubt many other rules that could be implemented which could be useful to the user.  For example, we might want to restrict the maximum stack depth of a function (i.e. limit the depth of the call graph that is reachable from a function as well as the local variables of those functions) for situations where we need to limit how much stack space is used (e.g. when writing an interrupt service routine that runs on an interrupt stack).  Additionally, funqual is set up to accept whatever input it is given from the user.  It might be possible to infer the funqual type qualifiers of functions (for example by checking what locks those functions try to grab) in order to reduce the load on the user.  It might also be possible to detect errors in the annotations from the user if funqual were given more information about the intent of those annotations.  Any and all additions to this type system just makes funqual and the concept of call graph constraint more useful.

Clearly there is a lot of work that could be done on funqual.  The idea that is brought to life in this paper is in its early infancy and needs to mature before it is ready to compete with other methods of static analysis.  More features need to be added to the tool, metrics need to be created so that funqual can be properly compared to other tools in its class, and the type system could be expanded to make it more usable.  A rich body of research could easily find its foundation herein.  

