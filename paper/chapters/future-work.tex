\chapter{Future Work}\label{sec:future}

Funqual is only a proof-of-concept and an exploration of user-defined call graph constraints.  As such, it leaves a lot of work open for further exploration.  This future work generally falls into three categories: expanding the abilities of the funqual tool, researching the impact that a tool like funqual could have during the development cycle, and expanding the type system discussed in this thesis.  

Funqual is unable to correctly check every program.  The most striking issue is the ability to check typedefs, array members, or struct members whose types are annotated function pointers.  Given the current libClang api, type checking these more complicated expressions is difficult.  At the moment, when querying an expression in the clang AST to determine the expression's type, attributes that were in the declaration are not included.  If these attributes were included, it would make querying the funqual type of any arbitrary expression trivial since the funqual type is encoded as an attribute.  Future work could go into improving the implementation of funqual as well as the libClang api.  

This research lacks any form of usability testing.  Funqual as a tool exists, and it can check programs against arbitrary constraints, but we currently have no idea how useful it is.  How often do developers need to check constraints like these?  How easy is funqual for developers to use?  Does a tool like funqual actually help developers while they are developing software?  How do we teach developers to think about the call graph and about how to restrict it?  Static Analysis tools exist to assist the developer, so in order to apply funqual to real world projects, all these questions must be answered.  A good deal of future work could go into answering these questions and into determining how we measure the value of a tool like this.  

The type system described in this thesis supports three types of constraints: $require\_direct\_call$, $restrict\_direct\_call$, and $restrict\_indirect\_call$.  There are without a doubt many other rules that could be implemented.  For example, we might want to restrict the maximum stack depth reachable from a function (i.e. limit the depth of the call graph that is reachable from a function as well as prevent recursion) for situations where we need to limit how much stack space is used (e.g., when writing an interrupt service routine that runs on a fixed 1Kb interrupt stack).  Additionally, funqual is set up to accept whatever input it is given from the user.  It might be possible to infer certain things about the direct type of functions based on their content or usage.  For example, a function which references global, static, or heap memory may be inferred to be nonreentrant; or a function that is registered as an interrupt handler may be inferred to be preemptive.  This would significantly reduce the load on the programmer to insert these annotations manually.  Any and all additions to this type system just makes funqual and the concept of call graph constraint more useful.

Clearly there is a lot of work that could be done on funqual.  The idea that is brought to life in this thesis is in its early infancy and needs to mature before it is ready to compete with other methods of static analysis.  More features need to be added to the tool, metrics need to be created so that funqual can be properly compared to other tools in its class, and the type system could be expanded to make it more usable.  A rich body of research could easily find its foundation herein.  

