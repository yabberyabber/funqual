\section{Glibc Nonreentrant Functions}\label{sec:app:reentrancy}

\interfootnotelinepenalty=10000

The GNU C Library Reference Manual warns against calling nonreentrant functions from signal handlers \cite{gnu-manual}.  A function which only accesses memory within its stack frame is reentrant because it cannot be effected by external state.  A function which accesses heap, global, or static memory may be nonreentrant if that memory can be modified by other execution environments.  This includes functions which reference a global datastructure (e.g. \lstinline{malloc}) or grab a global lock (e.g. \lstinline{printf}).  Reentrancy is a separate but similar concept to thread-safety; a reentrant function is thread-safe but a thread-safe function may not necessarily be reentrant.  As an example, \lstinline{printf} could be considered thread safe because it locks the stream while writing each character to it\footnote{Most implementations of \lstinline{printf} lock the stream per-character rather than per-string.  This means that running \mbox{\lstinline{printf("aaa")}} and \mbox{\lstinline{printf("bbb")}} concurrently might result in \mbox{\lstinline{"ababab"}} or \mbox{\lstinline{"aaabbb"}} but never in \mbox{\lstinline{"b0aa"}} or \mbox{\lstinline{SEGFAULT}}}.  However, if a call to \lstinline{printf} is interrupted while it holds the lock and the interrupt handler makes its own call to \lstinline{printf}, then the interrupt handler will wait for the lock.  Since the code holding the lock cannot run until the interrupt handler finishes, the system is in deadlock.  This is bad --- we would like to prevent this error as well as errors like it.  

Funqual can find and report this type of error.  To demonstrate this, we take a class assignment written for Operating Systems class (CSC453) that uses signal handlers, insert function type qualifiers, and create a rules file.  The assignment was to simulate a set of snakes crawling around the screen.  Each time the user pressed control-C (creating a \lstinline{SIGINT} signal), one of the snakes would disappear.  When the user tried to kill the process (creating a \lstinline{SIGQUIT} signal), the program would make each snake disappear and then terminate.  If a signal were sent during a call to a nonreentrant function, that function would be preempted by the signal handler; if the signal handler called that same nonreentrant function, this could result in undefined behavior.  

To make funqual detect this issue, we use two type qualifiers: \lstinline{preemptive} which applies to signal handlers, and \lstinline{non_reentrant} which applies to nonreenreant functions.  We also create one rule: $restrict\_indirect\_call(preemptive, non\_reentrant)$.  Since many of the nonreentrant functions we are concerned about are in the C standard library, these functions are annotated as \lstinline{non_reentrant} in the rules file.  Listing \ref{lst:app:reentrancy:rules} shows the rules file used.  The list of functions tagged as nonreentrant is incomplete but represents the ones used in this program.  In addition to tagging nonreentrant library functions in the rules file, the signal handlers in the code are tagged as \lstinline{preemptive}.  Listing \ref{lst:app:reentrancy:handlers} shows the two lines that were added to the program source to tag signal handlers.  

\noindent\begin{minipage}[t]{\linewidth}
\begin{lstlisting}[caption={Rules file for preventing preemptive functions from calling non\_reentrant functions.  Since this rules file contains no references to project-specific functions, the file could concievably be re-used by several projects.},label={lst:app:reentrancy:rules}]
rule restrict_indirect_call preemptive non_reentrant

tag c:@F@malloc non_reentrant
tag c:@F@free non_reentrant
tag c:@F@printf non_reentrant
tag c:@F@fprintf non_reentrant
tag c:@F@sprintf non_reentrant
tag c:@F@rand non_reentrant
\end{lstlisting}
\end{minipage}

\noindent\begin{minipage}[t]{\linewidth}
\begin{lstlisting}[language=c,caption={Lines inserted into C file to mark signal handlers as preemptive.},label={lst:app:reentrancy:handlers}]
void kill_snake() QTAG(preemptive);
void lwp_stop() QTAG(preemptive);
\end{lstlisting}
\end{minipage}

The size of this project was 458 lines of code\footnote{Line count achieved using the \lstinline{cloc} utility not including comments or blank lines.} contained in five \lstinline{.c} files with 40 edges in the call graph.  Funqual analyzed the source in about 2.9 seconds\footnote{Data collected on a T460 Lenovo Thinkpad with Quad Intel Core i5-6300U CPU at 2.4GHz.} --- 2.1 seconds were spent in libClang parsing the source, 0.8 seconds were spent traversing the AST to generate the call graph, 0.00001 seconds were spent checking all the call graph, and 0.00001 seconds were spent checking assignments. 

On the first run, funqual did not detect any call graph violations.  In order to test that the tool does actually detect errors, several illicit calls to \lstinline{printf} were inserted.  After doing so, funqual correctly detected and reported these errors.  Listing \ref{lst:app:reentrancy:output} shows the output from funqual when run on this modified codebase.

\noindent\begin{minipage}[t]{\linewidth}
\begin{lstlisting}[caption={Output from funqual when run on a project that had manually-inserted call graph violations},label={lst:app:reentrancy:output}]
Rule violation: `non_reentrant` function indirectly called from `preemptive` context
        Path:   snakemain.c::lwp_stop(int) (68,14)
        -calls: libLWP.c::get_init_context() (193,6)
        -calls: libLWP.c::printf(const char *, ...) (362,12)
\end{lstlisting}
\end{minipage}

As seen in Listing \ref{lst:app:reentrancy:output}, funqual successfully found a call graph violation that was manually inserted into the program source.  Additionally, funqual listed the locations in code where each call occurred between the \lstinline{preemptive} and \lstinline{non_reentrant} functions.  


